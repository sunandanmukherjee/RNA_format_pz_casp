import os
import argparse
import subprocess
import glob

def run_command(command):
    """Executes a command and checks for errors."""
    print(f"Executing: {' '.join(command)}")
    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error executing command: {' '.join(command)}")
        print(f"STDOUT: {result.stdout}")
        print(f"STDERR: {result.stderr}")
        exit(1)
    return result

def cleanup_files(patterns):
    """Removes files matching a list of glob patterns."""
    print("\nCleaning up intermediate files...")
    for pattern in patterns:
        for f in glob.glob(pattern):
            try:
                os.remove(f)
                print(f"Removed: {f}")
            except OSError as e:
                print(f"Error removing file {f}: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="A full pipeline to split, format, and combine RNA 3D models for RNA-Puzzles/CASP submission.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        '-t', '--template',
        required=True,
        help="Path to the official template PDB file."
    )
    parser.add_argument(
        '-m', '--models',
        required=True,
        nargs='+',  # Accepts one or more model files
        help="Space-separated list of input model PDB files, ordered by rank (e.g., model1.pdb model2.pdb ...)."
    )
    parser.add_argument(
        '-o', '--output',
        help="Name of the final combined PDB output file. \nIf not provided, it will be based on the template name (e.g., 'formatted_submission_template.pdb')."
    )
    parser.add_argument(
        '-k', '--keep-intermediate',
        action='store_true',
        help="If set, keeps the intermediate split and formatted files instead of deleting them."
    )

    args = parser.parse_args()

    # --- Verify that the helper scripts exist ---
    script_dir = os.path.dirname(os.path.realpath(__file__))
    split_script = os.path.join(script_dir, "split_PDB.py")
    format_script = os.path.join(script_dir, "format_PDB.py")

    if not os.path.exists(split_script):
        print(f"Error: 'split_PDB.py' not found in the script directory: {script_dir}")
        exit(1)
    if not os.path.exists(format_script):
        print(f"Error: 'format_PDB.py' not found in the script directory: {script_dir}")
        exit(1)

    # --- Define output file name ---
    if args.output:
        output_filename = args.output
    else:
        template_basename = os.path.splitext(os.path.basename(args.template))[0]
        output_filename = f"formatted_submission_{template_basename}.pdb"

    print(f"Starting RNA formatting pipeline...")
    print(f"Template: {args.template}")
    print(f"Models: {', '.join(args.models)}")
    print(f"Final Output: {output_filename}\n")

    # --- Processing Loop ---
    final_formatted_files = []
    files_to_cleanup = []

    for model_path in args.models:
        if not os.path.exists(model_path):
            print(f"Warning: Model file not found, skipping: {model_path}")
            continue

        print(f"--- Processing {model_path} ---")

        # 1. Split the model file
        # Assumes split_PDB.py might produce multiple models from a single input
        run_command(["python", split_script, model_path, "--model"])

        # Find the split files generated by the script
        model_basename = os.path.splitext(os.path.basename(model_path))[0]
        split_files = sorted(glob.glob(f"{model_basename}_model*.pdb"))
        
        if not split_files:
            print(f"Warning: No split models found for {model_path}. Assuming it's already a single model.")
            split_files = [model_path] # Treat the input as the split file
        else:
            files_to_cleanup.extend(split_files)

        # 2. Format each split file
        for split_file in split_files:
            print(f"Formatting {split_file} against template...")
            run_command(["python", format_script, "--template", args.template, "--model", split_file])
            
            # Find the formatted file (assuming format_PDB.py prefixes with "formatted_")
            formatted_file = f"formatted_{split_file}"
            if os.path.exists(formatted_file):
                final_formatted_files.append(formatted_file)
                files_to_cleanup.append(formatted_file)
            else:
                print(f"Error: Expected formatted file '{formatted_file}' not found after running format_PDB.py.")
                exit(1)

    # --- Combine into a single PDB file ---
    print(f"\nCombining {len(final_formatted_files)} models into {output_filename}...")
    with open(output_filename, 'w') as outfile:
        for i, formatted_file in enumerate(final_formatted_files, 1):
            outfile.write(f"MODEL        {i}\n")
            with open(formatted_file, 'r') as infile:
                outfile.write(infile.read())
            outfile.write("ENDMDL\n")
    
    print(f"Successfully created final submission file: {output_filename}")

    # --- Cleanup ---
    if not args.keep_intermediate:
        # Create unique patterns to avoid deleting original source files
        cleanup_patterns = []
        for model_path in args.models:
            model_basename = os.path.splitext(os.path.basename(model_path))[0]
            cleanup_patterns.append(f"{model_basename}_model*.pdb")
            cleanup_patterns.append(f"formatted_{model_basename}_model*.pdb")
        
        # In case an input was already a single model
        cleanup_patterns.append("formatted_*.pdb")

        cleanup_files(list(set(cleanup_patterns))) # Use set to remove duplicate patterns
    
    print("\nPipeline finished.")

if __name__ == "__main__":
    main()
